name: CI

"on":
  push:
    branches: [main]
  pull_request: {}
  workflow_dispatch: {}

env:
  # Used by Guepard CLI installed via Homebrew (guepard login -c ...)
  GUEPARD_API_TOKEN: ${{ secrets.GUEPARD_API_TOKEN }}

jobs:
  frontend-tests:
    name: Unit tests - frontend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Install dependencies (frontend)
        working-directory: components/frontend
        run: pnpm install --frozen-lockfile

      - name: Run frontend unit tests
        working-directory: components/frontend
        run: pnpm test:run

      - name: CI summary - frontend
        if: always()
        run: |
          {
            echo "### Frontend unit tests";
            echo "";
            echo "- Status: ${{ job.status }}";
            echo "- Directory: \`components/frontend\`";
            echo "- Command: \`pnpm test:run\`";
          } >> "$GITHUB_STEP_SUMMARY"

  api-tests:
    name: Unit tests - API
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies (api)
        working-directory: components/api
        run: pnpm install --frozen-lockfile

      - name: Run API unit tests
        working-directory: components/api
        run: pnpm test:unit

      - name: CI summary - API
        if: always()
        run: |
          {
            echo "### API unit tests";
            echo "";
            echo "- Status: ${{ job.status }}";
            echo "- Directory: \`components/api\`";
            echo "- Command: \`pnpm test\` (Bun test runner)";
          } >> "$GITHUB_STEP_SUMMARY"

  db-integration-tests:
    name: DB integration tests (clone from snapshot, validate)
    needs:
      - frontend-tests
      - api-tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install Guepard CLI via Homebrew
        run: |
          /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          brew tap guepard-corp/guepard
          brew install guepard

      - name: Guepard CLI login
        env:
          GUEPARD_API_TOKEN: ${{ env.GUEPARD_API_TOKEN }}
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "ðŸ” Executing: guepard logout"
          guepard logout || true
          echo "ðŸ” Executing: guepard login -c *** (token hidden)"
          guepard login -c "$GUEPARD_API_TOKEN"

      - name: Install jq
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "ðŸ” Executing: guepard usage to test login"
          echo "$(guepard usage)"

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Select base deployment
        id: base_deployment
        env:
          CI_DATABASE_URL: ${{ secrets.CI_DATABASE_URL }}
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          if [ -z "${CI_DATABASE_URL:-}" ]; then
            echo "Error: CI_DATABASE_URL secret is not set (connection string for main/production DB)"
            exit 1
          fi
          # Extract deployment name from URL host: postgresql://...@fierce-mountain-pe56o5.us-west-aws.db.guepard.run:port/... -> fierce-mountain-pe56o5
          HOST=$(echo "$CI_DATABASE_URL" | sed -n 's|.*@\([^:]*\):.*|\1|p')
          BASE_DEPLOYMENT_NAME=$(echo "$HOST" | cut -d. -f1)
          if [ -z "$BASE_DEPLOYMENT_NAME" ]; then
            echo "Error: Could not extract deployment name from CI_DATABASE_URL host (got: $HOST)"
            exit 1
          fi
          echo "ðŸ” Executing: guepard list deployments --json (resolving base deployment by name: $BASE_DEPLOYMENT_NAME)"
          DEPLOYMENTS_JSON=$(guepard list deployments --json)
          echo "$DEPLOYMENTS_JSON" | jq '.' > /tmp/deployments.json
          BASE_DEPLOYMENT_ID=$(echo "$DEPLOYMENTS_JSON" | jq -r --arg name "$BASE_DEPLOYMENT_NAME" '.[] | select(.name == $name) | .id' | head -n 1)
          if [ -z "$BASE_DEPLOYMENT_ID" ] || [ "$BASE_DEPLOYMENT_ID" = "null" ]; then
            echo "No deployment found with name '$BASE_DEPLOYMENT_NAME' (from CI_DATABASE_URL host)"
            exit 1
          fi
          echo "BASE_DEPLOYMENT_ID=$BASE_DEPLOYMENT_ID" >> "$GITHUB_ENV"
          echo "base_deployment_id=$BASE_DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"

      - name: Start compute for base deployment
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          guepard compute start -x "$BASE_DEPLOYMENT_ID" || true

      - name: Get main branch ID
        id: branch
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "ðŸ” Executing: guepard list branches -x $BASE_DEPLOYMENT_ID --json"
          BRANCHES_JSON=$(guepard list branches -x "$BASE_DEPLOYMENT_ID" --json)
          echo "$BRANCHES_JSON" | jq '.' > /tmp/branches.json
          BRANCH_ID=$(echo "$BRANCHES_JSON" | jq -r '.[] | select(.branch_name == "main") | .id' | head -n 1)
          if [ -z "$BRANCH_ID" ]; then
            echo "No main branch found for deployment $BASE_DEPLOYMENT_ID"
            exit 1
          fi
          echo "BRANCH_ID=$BRANCH_ID" >> "$GITHUB_ENV"
          echo "branch_id=$BRANCH_ID" >> "$GITHUB_OUTPUT"

      - name: Create snapshot from main branch
        id: snapshot
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "Creating snapshot from main branch for CI testing..."
          COMMIT_MESSAGE="CI test snapshot - $(date -u +%Y%m%d-%H%M%S)"
          echo "ðŸ” Executing: guepard commit --message \"$COMMIT_MESSAGE\" --deployment-id $BASE_DEPLOYMENT_ID --branch-id $BRANCH_ID --json"
          COMMIT_JSON=$(guepard commit \
            --message "$COMMIT_MESSAGE" \
            --deployment-id "$BASE_DEPLOYMENT_ID" \
            --branch-id "$BRANCH_ID" \
            --json || true)
          echo "$COMMIT_JSON" | jq '.' > /tmp/commit.json || true
          # Extract commit_id from response (array format)
          COMMIT_ID=$(echo "$COMMIT_JSON" | jq -r '.[0].commit_id // empty')
          if [ -z "$COMMIT_ID" ] || [ "$COMMIT_ID" = "null" ]; then
            echo "Failed to create snapshot. Response:"
            echo "$COMMIT_JSON" | jq '.' || echo "$COMMIT_JSON"
            exit 1
          fi
          echo "Commit created: $COMMIT_ID"
          echo "Waiting for commit to appear in commits list..."
          # Wait for commit to appear in commits list (verify it's available)
          for i in {1..30}; do
            echo "ðŸ” Executing: guepard list commits -x $BASE_DEPLOYMENT_ID --json (attempt $i/30)"
            COMMITS_JSON=$(guepard list commits -x "$BASE_DEPLOYMENT_ID" --json || true)
            COMMIT_EXISTS=$(echo "$COMMITS_JSON" | jq -r ".[] | select(.id == \"$COMMIT_ID\") | .id" | head -n 1)
            if [ "$COMMIT_EXISTS" = "$COMMIT_ID" ]; then
              echo "Commit found in commits list, ready to use as snapshot"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "Warning: Commit did not appear in commits list, but proceeding with commit_id as snapshot_id"
            else
              echo "Attempt $i/30: Waiting for commit to appear in commits list..."
              sleep 2
            fi
          done
          # commit_id from commit response = id in commits list = snapshot_id for cloning
          SNAPSHOT_ID="$COMMIT_ID"
          echo "Using commit_id as snapshot_id: $SNAPSHOT_ID"
          echo "SNAPSHOT_ID=$SNAPSHOT_ID" >> "$GITHUB_ENV"
          echo "snapshot_id=$SNAPSHOT_ID" >> "$GITHUB_OUTPUT"

      - name: Create two clones from same snapshot (clone + shadow for migration)
        id: clones
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "Creating two clones from snapshot $SNAPSHOT_ID (base: $BASE_DEPLOYMENT_ID):"
          echo "  1. Main clone (target for migrations, seed, invariants)"
          echo "  2. Shadow clone (for Prisma migrate --shadow-database-url)"
          echo ""
          echo "ðŸ” Executing: guepard clone -x $BASE_DEPLOYMENT_ID -s $SNAPSHOT_ID -n ci-clone-main --json (clone 1: main)"
          CLONE_JSON=$(guepard clone -x "$BASE_DEPLOYMENT_ID" -s "$SNAPSHOT_ID" -n "ci-clone-main" --json)
          echo "$CLONE_JSON" | jq '.' > /tmp/clone.json
          CLONE_DEPLOYMENT_ID=$(echo "$CLONE_JSON" | jq -r '.deployment.id')
          CONNECTION_STRING=$(echo "$CLONE_JSON" | jq -r '.compute.connection_string // empty')
          if [ -z "$CLONE_DEPLOYMENT_ID" ]; then
            echo "Failed to capture main clone deployment id"
            exit 1
          fi
          if [ -n "$CONNECTION_STRING" ] && [ "$CONNECTION_STRING" != "null" ]; then
            echo "DB_CONNECTION_STRING=$CONNECTION_STRING" >> "$GITHUB_ENV"
            echo "db_connection_string=$CONNECTION_STRING" >> "$GITHUB_OUTPUT"
          fi
          echo "CLONE_DEPLOYMENT_ID=$CLONE_DEPLOYMENT_ID" >> "$GITHUB_ENV"
          echo "clone_deployment_id=$CLONE_DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
          echo "Main clone id: $CLONE_DEPLOYMENT_ID"
          echo ""
          echo "ðŸ” Executing: guepard clone -x $BASE_DEPLOYMENT_ID -s $SNAPSHOT_ID -n ci-clone-shadow --json (clone 2: shadow)"
          SHADOW_CLONE_JSON=$(guepard clone -x "$BASE_DEPLOYMENT_ID" -s "$SNAPSHOT_ID" -n "ci-clone-shadow" --json)
          echo "$SHADOW_CLONE_JSON" | jq '.' > /tmp/shadow_clone.json
          SHADOW_CLONE_DEPLOYMENT_ID=$(echo "$SHADOW_CLONE_JSON" | jq -r '.deployment.id')
          SHADOW_CONNECTION_STRING=$(echo "$SHADOW_CLONE_JSON" | jq -r '.compute.connection_string // empty')
          if [ -z "$SHADOW_CLONE_DEPLOYMENT_ID" ]; then
            echo "Failed to capture shadow clone deployment id"
            exit 1
          fi
          if [ -n "$SHADOW_CONNECTION_STRING" ] && [ "$SHADOW_CONNECTION_STRING" != "null" ]; then
            echo "SHADOW_DATABASE_URL=$SHADOW_CONNECTION_STRING" >> "$GITHUB_ENV"
          fi
          echo "SHADOW_CLONE_DEPLOYMENT_ID=$SHADOW_CLONE_DEPLOYMENT_ID" >> "$GITHUB_ENV"
          echo "shadow_clone_deployment_id=$SHADOW_CLONE_DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
          echo "Shadow clone id: $SHADOW_CLONE_DEPLOYMENT_ID"

      - name: Start compute for main clone
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          guepard compute start -x "$CLONE_DEPLOYMENT_ID" || true

      - name: Wait for main clone compute to be healthy
        id: compute_ready
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "Waiting for compute of main clone $CLONE_DEPLOYMENT_ID to be healthy..."
          echo "Initial wait for compute to start initializing..."
          sleep 15
          for i in {1..20}; do
            echo "ðŸ” Executing: guepard compute status -x $CLONE_DEPLOYMENT_ID --json (attempt $i/20)"
            STATUS_JSON=$(guepard compute status -x "$CLONE_DEPLOYMENT_ID" --json 2>&1 || echo '{"error": "command_failed"}')
            if echo "$STATUS_JSON" | grep -q "502\|Bad Gateway\|Internal server error"; then
              echo "Attempt $i/20: Compute API returned error (still initializing), waiting 10s..."
            elif echo "$STATUS_JSON" | jq -e '.status' > /dev/null 2>&1; then
              HEALTHY=$(echo "$STATUS_JSON" | jq -r '.status // empty')
              if [ "$HEALTHY" = "Healthy" ]; then
                echo "Main clone compute is healthy."
                COMPUTE_CONNECTION=$(echo "$STATUS_JSON" | jq -r '.connection_string // empty')
                if [ -n "$COMPUTE_CONNECTION" ] && [ "$COMPUTE_CONNECTION" != "null" ]; then
                  echo "DB_CONNECTION_STRING=$COMPUTE_CONNECTION" >> "$GITHUB_ENV"
                  echo "db_connection_string=$COMPUTE_CONNECTION" >> "$GITHUB_OUTPUT"
                fi
                echo "Final connection string: $(echo "$DB_CONNECTION_STRING" | cut -c1-50)..."
                exit 0
              else
                echo "Attempt $i/20: Compute status is '$HEALTHY', waiting 10s..."
              fi
            else
              echo "Attempt $i/20: Unexpected response format: $(echo "$STATUS_JSON" | head -c 100)..."
            fi
            sleep 10
          done
          echo "Error: main clone compute did not become healthy in time (waited ~3.5 minutes)"
          echo "$STATUS_JSON" | head -20
          exit 1

      - name: Install dependencies (api)
        env:
          DATABASE_URL: ${{ env.DB_CONNECTION_STRING }}
        working-directory: components/api
        run: pnpm install --frozen-lockfile

      - name: Start compute for shadow clone
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "ðŸ” Executing: guepard compute start -x $SHADOW_CLONE_DEPLOYMENT_ID"
          guepard compute start -x "$SHADOW_CLONE_DEPLOYMENT_ID" || true

      - name: Wait for shadow clone compute to be healthy
        id: shadow_compute_ready
        run: |
          set -e
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          echo "Waiting for shadow clone compute $SHADOW_CLONE_DEPLOYMENT_ID to be healthy..."
          sleep 15
          for i in {1..20}; do
            echo "ðŸ” Executing: guepard compute status -x $SHADOW_CLONE_DEPLOYMENT_ID --json (attempt $i/20)"
            STATUS_JSON=$(guepard compute status -x "$SHADOW_CLONE_DEPLOYMENT_ID" --json 2>&1 || echo '{"error":"command_failed"}')
            if echo "$STATUS_JSON" | grep -qE "502|Bad Gateway|Internal server error"; then
              echo "Attempt $i/20: Compute API not ready yet, waiting 10s..."
            elif echo "$STATUS_JSON" | jq -e '.status' >/dev/null 2>&1; then
              HEALTHY=$(echo "$STATUS_JSON" | jq -r '.status // empty')
              if [ "$HEALTHY" = "Healthy" ]; then
                echo "âœ… Shadow clone compute is healthy."
                COMPUTE_CONNECTION=$(echo "$STATUS_JSON" | jq -r '.connection_string // empty')
                if [ -n "$COMPUTE_CONNECTION" ] && [ "$COMPUTE_CONNECTION" != "null" ]; then
                  echo "SHADOW_DATABASE_URL=$COMPUTE_CONNECTION" >> "$GITHUB_ENV"
                  echo "Shadow connection string set from compute status"
                fi
                exit 0
              else
                echo "Attempt $i/20: Compute status is '$HEALTHY', waiting 10s..."
              fi
            else
              echo "Attempt $i/20: Unexpected response: $(echo "$STATUS_JSON" | head -c 120)..."
            fi
            sleep 10
          done
          echo "âŒ Error: shadow clone compute did not become healthy in time"
          echo "$STATUS_JSON" | head -20
          exit 1

      - name: Run Prisma migrations against clone
        env:
          DATABASE_URL: ${{ env.DB_CONNECTION_STRING }}
          SHADOW_DATABASE_URL: ${{ env.SHADOW_DATABASE_URL }}
        working-directory: components/api
        run: |
          if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "null" ]; then
            echo "Error: DATABASE_URL is not set or is null"
            exit 1
          fi
          if [ -z "${SHADOW_DATABASE_URL:-}" ] || [ "$SHADOW_DATABASE_URL" = "null" ]; then
            echo "Error: SHADOW_DATABASE_URL is not set (expected from shadow clone compute)"
            exit 1
          fi
          export SHADOW_DATABASE_URL
          echo "Applying Prisma migrations to clone database..."
          echo "Using DATABASE_URL: $(echo "$DATABASE_URL" | cut -c1-60)..."
          echo "Using SHADOW_DATABASE_URL: $(echo "$SHADOW_DATABASE_URL" | cut -c1-60)..."
          rm -rf prisma/migrations/test-feature
          bunx prisma migrate diff \
            --from-migrations prisma/migrations \
            --to-schema-datamodel prisma/schema.prisma \
            --shadow-database-url "$SHADOW_DATABASE_URL" \
            --script \
            --output /tmp/pending-migration.sql
          if [ -s /tmp/pending-migration.sql ]; then
            mkdir -p prisma/migrations/test-feature
            cp /tmp/pending-migration.sql prisma/migrations/test-feature/migration.sql
          fi
          set +e
          bunx prisma migrate deploy 2>&1 | tee /tmp/deploy.out
          DEPLOY_RESULT=${PIPESTATUS[0]}
          set -e
          if [ "$DEPLOY_RESULT" -ne 0 ]; then
            if grep -q "000_baseline" /tmp/deploy.out && grep -qE "already exists|relation.*already exists" /tmp/deploy.out; then
              echo "Clone already has schema (000_baseline failed with already exists), marking applied and retrying deploy..."
              set +e
              bunx prisma migrate resolve --applied 000_baseline 2>&1 | tee /tmp/resolve.out
              R=${PIPESTATUS[0]}
              set -e
              if [ "$R" -ne 0 ] && ! grep -q "P3008\|already recorded as applied" /tmp/resolve.out; then
                cat /tmp/resolve.out
                exit 1
              fi
              bunx prisma migrate deploy
            else
              cat /tmp/deploy.out
              exit 1
            fi
          fi

      - name: Seed data with new format after migrations
        env:
          DATABASE_URL: ${{ env.DB_CONNECTION_STRING }}
        working-directory: components/api
        run: |
          if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "null" ]; then
            echo "Error: DATABASE_URL is not set or is null"
            exit 1
          fi
          echo "Seeding test data with new format..."
          echo "Using DATABASE_URL: $(echo "$DATABASE_URL" | cut -c1-60)..."
          export DATABASE_URL
          bunx prisma generate
          bun run prisma/integration/seed.ts

      - name: Run DB invariants tests
        env:
          # Use Guepard clone compute connection string directly as DATABASE_URL
          DATABASE_URL: ${{ env.DB_CONNECTION_STRING }}
        working-directory: components/api
        run: |
          if [ -z "$DATABASE_URL" ] || [ "$DATABASE_URL" = "null" ]; then
            echo "Error: DATABASE_URL is not set or is null"
            exit 1
          fi
          echo "Running Prisma DB invariants tests against $(echo "$DATABASE_URL" | cut -c1-60)..."
          export DATABASE_URL
          pnpm test:db

      - name: CI summary - database
        if: always()
        run: |
          {
            echo "### DB integration tests (clone from snapshot, validate)";
            echo "";
            echo "- Status: ${{ job.status }}";
            echo "- Original Prod Database: \`${BASE_DEPLOYMENT_ID:-n/a}\`";
            echo "- Snapshot ID: \`${SNAPSHOT_ID:-n/a}\`";
            echo "- Clone database: \`${CLONE_DEPLOYMENT_ID:-n/a}\`";
            echo "- Shadow clone (for migrate): \`${SHADOW_CLONE_DEPLOYMENT_ID:-n/a}\`";
            echo "- Steps:";
            echo "  - Resolve base deployment from CI_DATABASE_URL";
            echo "  - \`guepard commit\` (create snapshot), create two clones from same snapshot (main + shadow for migrate)";
            echo "  - Wait for both clone computes to be healthy";
            echo "  - \`prisma migrate deploy\` (apply migrations to clone)";
            echo "  - Seed test data with new format";
            echo "  - Prisma invariants tests against migrated + seeded clone";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Drop CI databases
        if: always()
        run: |
          eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
          if [ -n "${SHADOW_CLONE_DEPLOYMENT_ID:-}" ]; then
            echo "Cleaning up shadow clone deployment: $SHADOW_CLONE_DEPLOYMENT_ID"
            echo "ðŸ” Executing: guepard deploy -x $SHADOW_CLONE_DEPLOYMENT_ID -y"
            guepard deploy -x "$SHADOW_CLONE_DEPLOYMENT_ID" -y || echo "Shadow clone cleanup failed (possibly already removed)"
          fi
          if [ -n "${CLONE_DEPLOYMENT_ID:-}" ]; then
            echo "Cleaning up clone deployment: $CLONE_DEPLOYMENT_ID"
            echo "ðŸ” Executing: guepard deploy -x $CLONE_DEPLOYMENT_ID -y"
            guepard deploy -x "$CLONE_DEPLOYMENT_ID" -y || echo "Clone cleanup failed (possibly already removed)"
          fi
          if [ -z "${CLONE_DEPLOYMENT_ID:-}" ] && [ -z "${SHADOW_CLONE_DEPLOYMENT_ID:-}" ]; then
            echo "No clone deployment IDs set, nothing to clean up"
          fi

  api-contract-tests:
    name: API contract tests
    needs:
      - db-integration-tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies (api)
        working-directory: components/api
        run: pnpm install --frozen-lockfile

      - name: Run API contract tests
        env:
          TEST_MODE: contract
        working-directory: components/api
        run: bun run test:contract

      - name: CI summary - API contract tests
        if: always()
        run: |
          {
            echo "### API contract tests";
            echo "";
            echo "- Status: ${{ job.status }}";
            echo "- Directory: \`components/api\`";
            echo "- Command: \`pnpm test\` (with TEST_MODE=contract)";
          } >> "$GITHUB_STEP_SUMMARY"
